/**
   The MIT License (MIT)

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.

*/


#include <ESP32Servo.h>
#include "Wire.h"
#include "MPU6050.h"

#define ESC_HIGH_DEFAULT 180
#define ESC_LOW_DEFAULT 00
//PINS
#define SET_PIN 4
#define SPEED1PIN 13
#define SERVO1PIN 14
#define SERVO2PIN 15
#define SPEED2PIN 12
#define RXD2 16
#define TXD2 17

#define ROLL_LIMIT 50
#define PITCH_LIMIT 50

//#define SETSPEED //uncomment to set speed controller

// create four servo objects 
Servo speed1;
Servo speed2;
Servo servo1;
Servo servo2;
//Servo servo5;
// Published values for SG90 servos; adjust if needed
int minUs = 000;
int maxUs = 2000;

int pos = 0;      // position in degrees
ESP32PWM pwm;
MPU6050 mpu;




void drawtelem(void){
  char textout[128];
  if(Serial2.available()){
    Serial2.readBytesUntil('\n',textout,256);
    Serial.println(textout);
  }
}

void sethc12(const char *s){
  digitalWrite(SET_PIN,0);
  delay(200);
//  Serial1.print("AT+");
  Serial2.println(s);
//  Serial1.print("\n");
  delay(1000);
  while(!Serial2.available());//wait for reply
  drawtelem();
  digitalWrite(SET_PIN,1);
  delay(1000);
}
/*Initializate function*/
void initializempu() {
 
  mpu.initialize();

  Serial.println("Testing MPU6050 connection...");
  if(mpu.testConnection() ==  false){
    Serial.println("MPU6050 connection failed");
    while(true);
  }
  else{
    Serial.println("MPU6050 connection successful");
  }
  Serial.println("Updating internal sensor offsets...\n");


  Serial.println("\nPID tuning Each Dot = 100 readings");
  /*
  PID tuning (actually PI) works like this: changing the offset in the MPU6050 gives instant results, 
  allowing us to use the Proportional and Integral parts of the PID to find the ideal offsets. 
  The Integral uses the error from the set point (which is zero) and adds a fraction of this error to 
  the integral value. Each reading reduces the error towards the desired offset. The greater 
  the error, the more we adjust the integral value. 
  
  The Proportional part helps by filtering out noise from the integral calculation. The Derivative part is 
  not used due to noise and the sensor being stationary. With the noise removed, the integral value stabilizes 
  after about 600 readings. At the end of each set of 100 readings, the integral value is used for the actual 
  offsets, and the last proportional reading is ignored because it reacts to any noise.
  */
  Serial.println("\nXAccel\t\tYAccel\t\tZAccel\t\tXGyro\t\tYGyro\t\tZGyro");
  mpu.CalibrateAccel(15);
  mpu.CalibrateGyro(15);
  Serial.println("\n1500 Readings");
  mpu.PrintActiveOffsets();
  mpu.CalibrateAccel(1);
  mpu.CalibrateGyro(1);
  Serial.println("700 Total Readings");
  mpu.PrintActiveOffsets();
  mpu.CalibrateAccel(1);
  mpu.CalibrateGyro(1);
  Serial.println("800 Total Readings");
  mpu.PrintActiveOffsets();
  mpu.CalibrateAccel(1);
  mpu.CalibrateGyro(1);
  Serial.println("900 Total Readings");
  mpu.PrintActiveOffsets();
  mpu.CalibrateAccel(1);
  mpu.CalibrateGyro(1);
  Serial.println("1000 Total Readings");
  mpu.PrintActiveOffsets();
  Serial.println("\nAny of the above offsets will work nicely \n\nProving the PID with other method:");
}

#define MAX_ROLL 50
#define MAX_PITCH 50

uint8_t chanval[16];
int16_t roll,pitch,yaw;
uint8_t elevon1,elevon2;

void setup() {
 
  pinMode(SET_PIN, OUTPUT);
  digitalWrite(SET_PIN,1);

	// Allow allocation of all timers
	ESP32PWM::allocateTimer(0);
	ESP32PWM::allocateTimer(1);
	ESP32PWM::allocateTimer(2);
	ESP32PWM::allocateTimer(3);
	Serial.begin(115200);
  Serial2.begin(9600, SERIAL_8N1, RXD2, TXD2);    //Hardware Serial of ESP32  pinMode(SET_PIN,OUTPUT);
  
  Wire.begin(); 
  delay(1000);//delay for components to power up

  initializempu();
  pitch=0;yaw=0;roll=0;

  servo1.setPeriodHertz(50);      // Standard 50hz servo
	servo2.setPeriodHertz(50);      // Standard 50hz servo
	speed1.setPeriodHertz(50);      // Standard 50hz servo
	speed2.setPeriodHertz(50);      // Standard 50hz servo
	//servo5.setPeriodHertz(50);      // Standard 50hz servo
	servo1.attach(SERVO1PIN, minUs, maxUs);
	servo2.attach(SERVO2PIN, minUs, maxUs);
	speed1.attach(SPEED1PIN, minUs, maxUs);
	speed2.attach(SPEED2PIN, minUs, maxUs);
  sethc12("AT");

  for(int i=0;i<9;i++)chanval[i]=90;

  elevon1=90; elevon2=90;

  servo1.write(elevon1);
  servo2.write(elevon2);

  #ifdef SETSPEED
    SetThrottleRange();
  #endif
}


void dogyro(void){
  int16_t ax, ay, az, gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

/*
  roll = atan2(ay , az) * (180.0*M_PI);
  pitch = atan2((- ax) , sqrt(ay * ay + az * az)) * (180.0*M_PI);
*/

//convert radians to degrees
  pitch=atan2(ax,az) * (180.0 / M_PI);
  roll=atan2(ay,az) * (180.0 / M_PI);
  
/*
  Serial.print("a/g:\t");

  Serial.print(ax); Serial.print("\t");
  Serial.print(ay); Serial.print("\t");
  Serial.print(az); Serial.print("\t");

  Serial.print(gx); Serial.print("\t");
  Serial.print(gy); Serial.print("\t");
  Serial.print(gz); Serial.print("\t");

  Serial.print(roll); Serial.print("\t");
  Serial.print(pitch); Serial.print("\t");
  Serial.println(yaw);
*/




}

void SetThrottleRange()
{
	Serial.println("In Set Throttle Range mode,Turn on ESC and press enter.");
 while (!Serial.available())
	{
    speed1.write(ESC_HIGH_DEFAULT);
	}
	Serial.read();
   

	Serial.println("Connect the ESC now. After connecting the ESC, you should hear the ESC startup tones. Shortly afterwards, you should hear two beeps indicating that the ESC has registered the high throttle value. Immediately after hearing the two beeps, push any key. If you don't do so in 5 sec, the ESC will go into program mode");

	// Wait for user input
	while (!Serial.available())
	{
	}
	Serial.read();

	Serial.println("\nSetting the low throttle setting. If this happens successfully, you should hear several beeps indicating the input voltage supplied to the ESC followed by a long beep indicating that the low throttle has been set. After this point, push any key to proceed, your ESC is ready to be used");

  speed1.write(ESC_LOW_DEFAULT);

	// Wait for user input
	while (!Serial.available())
	{
	}
	Serial.read();
}

void readchannel(){
//if my reception is lost elevons woll be 90 degrees
	//servo5.attach(servo5Pin, minUs, maxUs);
  int byte=0;
  while(byte!=255){//wait for 255 start byte
    if(!Serial2.available()){
      return;
    }
    byte=Serial2.read();
  }

    //read 8 channels x1,y1,x2,y2,.....
  while(!Serial2.readBytes(chanval,8)==8);//wait for 8 more bytes
  
  
}

void dooutput(){
// stick 1 channel[0] controls throttle only
// stick 2 channel[2] and channel[3] controls roll and pitch
//limit pitch and roll to 90 degrees
  pitch=constrain(pitch,-90,90);
  roll=constrain(roll,-90,90);

  int16_t er,el;
///fixme
//only limit the elevons when the pitch or roll are over the limit
//  e1=(abs(pitch)>=PITCH_LIMIT)?constrain(chanval[3],90-PITCH_LIMIT,90+PITCH_LIMIT)-pitch:chanval[3]-pitch;
//  e2=(abs(roll)>=ROLL_LIMIT)?constrain(chanval[2],90-ROLL_LIMIT,90+ROLL_LIMIT)-roll:chanval[2]-roll;
//  e1=chanval[3]-pitch;
//  e2=chanval[2]-roll;
  er=90;
  el=90;
  er+=chanval[2]-90;
  el-=chanval[2]-90;
  er-=roll;
  el+=roll;
  int pitchin = chanval[3]-90;

  Serial.print(er);Serial.print('\t');
  Serial.println(el);

  er+=pitchin;
  el+=pitchin;

  er+=pitch;
  el+=pitch;

  Serial.print(er);Serial.print('\t');
  Serial.println(el);

  elevon1=constrain(er,0,180);
  elevon2=constrain(el,0,180);


/*  
  Serial.print(pitch);Serial.print("\t");
  Serial.print(roll);Serial.print("\t");
  Serial.print(e1);Serial.print("\t");
  Serial.print(e2);Serial.println("\t");
*/

//    speed1.write(channel[0]);
    delay(1);
    servo1.write(elevon1);

//    servo1.write(chanval[2]);
    delay(1);
    servo2.write(elevon2);
//    servo2.write(chanval[3]);
    delay(1);


}

void loop() {
  dogyro();
  readchannel();
  dooutput();
//  writeservos();
/*
	for (pos = 0; pos <= ESC_HIGH_DEFAULT; pos += 1) { // sweep from 0 degrees to 180 degrees
		// in steps of 1 degree
		servo1.write(pos);
		delay(1);             // waits 20ms for the servo to reach the position
	}
	for (pos = ESC_HIGH_DEFAULT; pos >= 0; pos -= 1) { // sweep from 180 degrees to 0 degrees
		servo1.write(pos);
		delay(1);
	}

	for (pos = 0; pos <= ESC_HIGH_DEFAULT; pos += 1) { // sweep from 0 degrees to 180 degrees
		// in steps of 1 degree
		servo2.write(pos);
		delay(1);             // waits 20ms for the servo to reach the position
	}
	for (pos = ESC_HIGH_DEFAULT; pos >= 0; pos -= 1) { // sweep from 180 degrees to 0 degrees
		servo2.write(pos);
		delay(1);
	}

	for (pos = 0; pos <= 40; pos += 1) { // sweep from 0 degrees to 180 degrees
		// in steps of 1 degree
		speed1.write(pos);
		delay(10);             // waits 20ms for the servo to reach the position
	}
	for (pos = 40; pos >= 0; pos -= 1) { // sweep from 180 degrees to 0 degrees
		speed1.write(pos);
		delay(10);
	}

	for (pos = 0; pos <= 180; pos += 1) { // sweep from 0 degrees to 180 degrees
		// in steps of 1 degree
		speed2.write(pos);
		delay(1);             // waits 20ms for the servo to reach the position
	}
	for (pos = 180; pos >= 0; pos -= 1) { // sweep from 180 degrees to 0 degrees
		speed2.write(pos);
		delay(1);
	}
*/

//	servo1.detach();
//	servo2.detach();;
//	servo3.detach();
//	servo4.detach();

//	delay(3000);
  
}

